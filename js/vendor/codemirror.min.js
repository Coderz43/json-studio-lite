/*! JSON Studio Lite â€“ CodeMirror shim V5.3
    (numbers + pixel-perfect highlight + dark-mode readable current line + single scrollbar) */
(function () {
  if (window.CodeMirror && window.CodeMirror.__JSL_V53__) return;

  function createEditor(opts){
    const parent   = (opts && opts.parent) ? opts.parent : document.body;
    const readOnly = !!(opts && opts.readOnly);

    while (parent.firstChild) parent.removeChild(parent.firstChild);

    // skeleton
    const root     = mk('div','cm-root');     parent.appendChild(root);
    const gutter   = mk('div','cm-gutter');   root.appendChild(gutter);
    const scroller = mk('div','cm-scroller'); root.appendChild(scroller);

    // yellow current line (behind text)
    const hl = mk('div','cm-hl');
    hl.style.pointerEvents = 'none';
    hl.style.zIndex = '0';
    if ((document.documentElement.getAttribute('data-theme') || '').toLowerCase() !== 'light') {
      hl.style.background = 'rgba(255,246,204,.88)';   // dark-mode contrast
    }
    scroller.appendChild(hl);

    // ghost overlay to render active-line text in black on top of yellow (dark mode)
    const ghost = mk('div','cm-ghost');  // styled in CSS
    ghost.style.zIndex = '2';
    scroller.appendChild(ghost);

    // surfaces
    let ta = null, pre = null;
    if (!readOnly){
      root.classList.add('cm-has-ta');              // flag: textarea owns scrolling
      scroller.style.overflow = 'hidden';           // prevent 2nd scrollbar
      ta = mk('textarea','cm-textarea');
      ta.spellcheck = false;
      ta.value = (opts && opts.doc) || "";
      ta.style.position = 'relative';
      ta.style.zIndex = '1';
      ta.style.overflow = 'auto';                   // the only scrollbar in edit mode
      scroller.appendChild(ta);
      if (opts && opts.autofocus) setTimeout(()=>ta.focus(),0);
    } else {
      root.classList.remove('cm-has-ta');
      scroller.style.overflow = 'auto';             // wrapper owns scrolling in readonly
      pre = mk('pre','cm-jsonview');
      pre.setAttribute('aria-label','JSON output');
      pre.style.position = 'relative';
      pre.style.zIndex = '1';
      scroller.appendChild(pre);
      renderJson(pre, (opts && opts.doc) || "");
    }

    // ---- shared metrics ----
    let lineH = 20, padTop = 8, padLeft = 12, alignNudge = 0;

    function readMetricsFrom(el){
      if (!el) return;
      const cs = getComputedStyle(el);
      lineH   = parseFloat(cs.lineHeight)  || 20;
      padTop  = parseFloat(cs.paddingTop)  || 0;
      padLeft = parseFloat(cs.paddingLeft) || 12;

      const rs = getComputedStyle(root);
      const n  = parseFloat(rs.getPropertyValue('--cm-align-nudge'));
      alignNudge = isNaN(n) ? 0 : n;

      root.style.setProperty('--cm-line-h',  lineH  + 'px');
      root.style.setProperty('--cm-pad-top', padTop + 'px');
      root.style.setProperty('--cm-pad-left',padLeft+ 'px');
    }

    // caret mirror for exact highlight Y
    let mirror = null;
    function ensureMirror(){
      if (mirror || !ta) return;
      mirror = mk('div');
      mirror.style.cssText = [
        'position:absolute','top:0','left:0','visibility:hidden',
        'white-space:pre-wrap','word-wrap:break-word','overflow-wrap:break-word',
        'pointer-events:none'
      ].join(';');
      scroller.appendChild(mirror);
    }
    function copyTextMetrics(from, to){
      const cs = getComputedStyle(from);
      to.style.font          = cs.font;
      to.style.letterSpacing = cs.letterSpacing;
      to.style.lineHeight    = cs.lineHeight;
      to.style.paddingTop    = cs.paddingTop;
      to.style.paddingRight  = cs.paddingRight;
      to.style.paddingBottom = cs.paddingBottom;
      to.style.paddingLeft   = cs.paddingLeft;
      to.style.border        = '0';
      to.style.width         = from.clientWidth + 'px';
    }
    function caretTopPx(){
      if (!ta) return padTop;
      ensureMirror(); copyTextMetrics(ta, mirror);
      const val = ta.value || "";
      const pos = ta.selectionStart || 0;

      const safeBefore = val.slice(0,pos)
        .replace(/&/g,'&amp;').replace(/</g,'&lt;')
        .replace(/\n/g,'<br/>').replace(/ {2}/g,' &nbsp;');

      mirror.innerHTML = safeBefore + '<span id="__cm_c">&#8203;</span>';
      const mark = mirror.querySelector('#__cm_c');
      const y = mark ? mark.offsetTop : padTop;
      return y - (ta.scrollTop || 0);
    }

    // ---- gutter paint / sync ----
    let lastLines = -1;
    const countLines = (s)=> Math.max(1, String(s||'').split(/\r\n|\n|\r/).length);

    function paintGutter(){
      const text  = readOnly ? (pre.__rawPretty || "") : (ta.value || "");
      const lines = countLines(text);
      if (lines !== lastLines){
        lastLines = lines;
        const frag = document.createDocumentFragment();
        for (let i=1;i<=lines;i++){
          const n = mk('div','cm-ln'); n.textContent = i; frag.appendChild(n);
        }
        gutter.innerHTML = ''; gutter.appendChild(frag);
      }
      if (!readOnly) highlight();
    }

    function syncScroll(){
      // Single scrollbar:
      // - edit mode: textarea scrollTop
      // - readonly: scroller scrollTop
      const st = ta ? ta.scrollTop : scroller.scrollTop;
      gutter.scrollTop = st;
    }

    // ---- ghost helpers ----
    function caretLine(){
      if (!ta) return 1;
      const pos = ta.selectionStart || 0;
      return (ta.value.slice(0,pos).match(/\n/g)||[]).length + 1;
    }
    function isMulti(){
      if (!ta) return false;
      const s = ta.selectionStart ?? 0, e = ta.selectionEnd ?? 0;
      return (ta.value.slice(s,e).match(/\n/g)||[]).length > 0;
    }
    function currentLineText(){
      if (!ta) return "";
      const pos = ta.selectionStart || 0, val = ta.value || "";
      const start = val.lastIndexOf("\n", Math.max(0, pos - 1)) + 1;
      const nl = val.indexOf("\n", pos);
      const end = nl === -1 ? val.length : nl;
      return val.slice(start, end);
    }
    function updateGhost(topPx, hidden){
      if (hidden || !ta) {
        ghost.style.transform = 'translateY(-9999px)';
        return;
      }
      const isLight = (document.documentElement.getAttribute('data-theme') || '').toLowerCase() === 'light';
      if (isLight) { ghost.style.transform = 'translateY(-9999px)'; return; }

      let line = currentLineText().replace(/ /g, '\u00A0');
      ghost.textContent = line;

      const leftShift = -(ta.scrollLeft || 0);
      ghost.style.transform = `translate(${leftShift}px, ${Math.max(0, Math.round(topPx))}px)`;
    }

    // ---- highlight ----
    function highlight(){
      if (!ta) return;
      const multi = isMulti();
      hl.style.opacity = multi ? '0' : '1';

      const line = caretLine();
      const kids = gutter.children;
      for (let i=0;i<kids.length;i++){
        kids[i].classList.toggle('is-active', !multi && (i+1)===line);
      }

      let top = caretTopPx();
      if (!isFinite(top)) top = (padTop + (line-1)*lineH) - (ta.scrollTop||0);
      top += alignNudge;

      const y = Math.max(0, Math.round(top));
      hl.style.transform = `translateY(${y}px)`;
      hl.style.height = lineH + 'px';

      updateGhost(y, multi);
    }

    // ---- events ----
    const listeners = new Set();

    if (ta){
      readMetricsFrom(ta);
      paintGutter();

      ta.addEventListener('input',  ()=>{ readMetricsFrom(ta); paintGutter(); listeners.forEach(fn=>{try{fn(ta.value);}catch{}}); });
      ta.addEventListener('scroll', ()=>{ syncScroll(); highlight(); });
      ['click','keyup','select','paste','cut'].forEach(ev =>
        ta.addEventListener(ev, ()=>{ readMetricsFrom(ta); highlight(); })
      );

      // Wheel routing no longer needed visually, but keeps smoothness
      scroller.addEventListener('wheel', (e)=>{ ta.scrollTop += e.deltaY; e.preventDefault(); }, {passive:false});
    } else {
      readMetricsFrom(pre);
      paintGutter();
      // readonly: wrapper scroll drives gutter
      scroller.addEventListener('scroll', syncScroll);
    }

    // resize / zoom
    const ro = new ResizeObserver(()=>{ if(ta && mirror) copyTextMetrics(ta, mirror); readMetricsFrom(ta||pre); paintGutter(); if (ta) highlight(); });
    ro.observe(root);
    window.addEventListener('resize', ()=>{ readMetricsFrom(ta||pre); paintGutter(); if (ta) highlight(); });

    if (!readOnly) highlight();

    return {
      getValue(){ return readOnly ? (pre.__raw || '') : (ta.value || ''); },
      setValue(v){
        v = String(v == null ? '' : v);
        if (readOnly){ renderJson(pre, v); }
        else { ta.value = v; }
        readMetricsFrom(ta||pre); paintGutter(); if (ta) highlight();
      },
      onChange(fn){ if (typeof fn==='function') listeners.add(fn); return ()=>listeners.delete(fn); },
      _root: root
    };
  }

  // ---- JSON pretty renderer with token colors ----
  function renderJson(pre, text){
    pre.__raw = String(text || '');
    let pretty = pre.__raw; try{ pretty = JSON.stringify(JSON.parse(pre.__raw), null, 2); } catch {}
    pre.__rawPretty = pretty;

    pre.innerHTML = pretty.split(/\r\n|\n|\r/).map(line=>{
      const safe = line.replace(/&/g,'&amp;').replace(/</g,'&lt;');
      return `<div class="cm-row"><span class="cm-code">${colorize(safe)}</span></div>`;
    }).join('');
  }
  function colorize(s){
    s = s.replace(/(&quot;|")([^"\\]*(?:\\.[^"\\]*)*)(&quot;|")(\s*:\s*)/g,
      (_,a,key,c,colon)=> `<span class="tok-key">"${key}"</span>${colon}`);
    s = s.replace(/(:\s*)("([^"\\]*(\\.[^"\\]*)*)")/g,
      (_,pre, full)=> `${pre}<span class="tok-str">${full}</span>`);
    s = s.replace(/(:\s*)(-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)/g,
      (_,pre,num)=> `${pre}<span class="tok-num">${num}</span>`);
    s = s.replace(/(:\s*)(true|false|null)\b/g,
      (_,pre,kw)=> `${pre}<span class="tok-bool">${kw}</span>`);
    return s;
  }

  function mk(tag, cls){
    const n = document.createElement(tag);
    if (cls) n.className = cls;
    return n;
  }

  // expose
  window.CodeMirror = window.CodeMirror || {};
  window.CodeMirror.createEditor = createEditor;
  window.CodeMirror.langText = true;
  window.CodeMirror.langJSON = true;
  window.CodeMirror.__JSL_V53__ = true;
})();
