/*! JSON Studio Lite â€“ Minimal Papa Parse compatible build (CSV)
    Exposes global `Papa.parse(input, opts)`
    Supported opts:
      - header: boolean (default: false)
      - delimiter: string (default: auto-detect among , | ; \t)
      - dynamicTyping: boolean (number/boolean/null casting)
      - skipEmptyLines: true | "greedy"
      - transformHeader: fn(h) -> h
      - transform: fn(v) -> v
    Returns: { data, errors: [], meta: { delimiter, linebreak } }
    Note: This is a lightweight implementation for in-browser use. */
(function(){
  if (window.Papa && typeof window.Papa.parse === "function") return;

  function detectDelimiter(sample){
    const cands = [",","|",";","\t"];
    const lines = (sample||"").split(/\r\n|\n|\r/).slice(0, 5);
    const scores = cands.map(d => ({
      d,
      c: lines.map(l => (l.match(new RegExp(escapeRegExp(d),"g"))||[]).length).reduce((a,b)=>a+b,0)
    })).sort((a,b)=>b.c-a.c);
    return (scores[0] && scores[0].c>0) ? scores[0].d : ",";
  }
  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

  function dynamicCast(v){
    if (v === "") return "";
    if (/^(true|false)$/i.test(v)) return /^true$/i.test(v);
    if (/^null$/i.test(v)) return null;
    if (!isNaN(v) && !/^0\d+/.test(v)) {
      const n = Number(v);
      if ((""+n)===v || /^\d+(\.\d+)?$/.test(v)) return n;
    }
    return v;
  }

  function parseCSV(input, opt){
    const text = (input||"");
    const linebreak = (/\r\n/.test(text)) ? "\r\n" : "\n";
    const delim = (opt.delimiter && opt.delimiter!=="auto") ? (opt.delimiter==="\\t" ? "\t" : opt.delimiter) : detectDelimiter(text);

    const out = [];
    const errors = [];
    const len = text.length;
    let i = 0, field="", row=[], inQuotes=false;

    function pushField(){
      let v = field;
      if (opt.transform) v = opt.transform(v);
      if (opt.dynamicTyping) v = dynamicCast(v);
      row.push(v);
      field = "";
    }
    function pushRow(){
      // skip empty rows
      const isEmpty = row.length===1 && (row[0]==="" || row[0]==null);
      if (opt.skipEmptyLines && isEmpty) { row=[]; return; }
      if (opt.skipEmptyLines==="greedy" && row.every(c => (c===""||c==null))) { row=[]; return; }
      out.push(row); row=[];
    }

    while (i < len) {
      const ch = text[i];

      if (inQuotes) {
        if (ch === '"') {
          // escaped quote?
          if (i+1 < len && text[i+1] === '"') { field += '"'; i+=2; continue; }
          inQuotes = false; i++; continue;
        } else {
          field += ch; i++; continue;
        }
      } else {
        if (ch === '"') { inQuotes = true; i++; continue; }

        // delimiter
        if (ch === delim) { pushField(); i++; continue; }

        // linebreaks
        if (ch === "\r" || ch === "\n") {
          pushField();
          // consume CRLF as one
          if (ch === "\r" && i+1 < len && text[i+1] === "\n") i++;
          i++;
          pushRow();
          continue;
        }

        // regular char
        field += ch; i++; continue;
      }
    }
    // flush last field/row
    pushField();
    pushRow();

    return { data: out, errors, meta: { delimiter: delim, linebreak } };
  }

  function applyHeader(table, opt){
    if (!table.length) return { data: [], errors: [] };
    let headers = table[0].map(h => (opt.transformHeader ? opt.transformHeader(String(h||"")) : String(h||"")));
    const rows = table.slice(1).map(r => {
      const o = {};
      for (let i=0;i<headers.length;i++){
        const key = headers[i] || `col${i+1}`;
        o[key] = r[i] !== undefined ? r[i] : "";
      }
      return o;
    });
    return { data: rows, errors: [] };
  }

  window.Papa = {
    parse: function(input, opt){
      opt = opt || {};
      const parsed = parseCSV(input, opt);

      // If header=false, data is array-of-arrays
      if (!opt.header) return parsed;

      // If header=true, convert to array-of-objects
      const withHeader = applyHeader(parsed.data, opt);
      return {
        data: withHeader.data,
        errors: (parsed.errors||[]).concat(withHeader.errors||[]),
        meta: parsed.meta
      };
    }
  };
})();
